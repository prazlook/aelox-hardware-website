@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-theme-dark text-theme-text-primary;
  }
}

/* Animations existantes conservées */
@keyframes zap-trace {
  to {
    stroke-dashoffset: 0;
  }
}

@keyframes server-blink {
  0%, 100% { opacity: 1; }
  25% { opacity: 0.2; }
  50% { opacity: 0.8; }
  75% { opacity: 0.4; }
}

@keyframes marching-ants {
  from {
    stroke-dashoffset: 0;
  }
  to {
    stroke-dashoffset: 36;
  }
}

@keyframes slide-in-item {
  from {
    opacity: 0;
    transform: translateX(-15px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes draw-border {
  from {
    stroke-dashoffset: 500;
  }
  to {
    stroke-dashoffset: 0;
  }
}

@keyframes flicker-in {
  0%, 100% { opacity: 1; }
  10%, 30%, 50%, 70%, 90% { opacity: 0; }
  20%, 40%, 60%, 80% { opacity: 1; }
}

@keyframes shutdown-wave {
  to {
    stroke-dashoffset: 0;
  }
}

@keyframes flicker-and-fade {
  0% { opacity: 1; color: inherit; }
  20% { opacity: 0.5; }
  40% { opacity: 1; }
  60% { opacity: 0.2; }
  80% { opacity: 0.8; }
  90% { opacity: 1; color: #4a5568; }
  100% { opacity: 0.3; color: #4a5568; }
}

@keyframes gentle-shutdown-flicker {
  0% { opacity: 1; }
  25% { opacity: 0.6; }
  50% { opacity: 0.8; }
  75% { opacity: 0.4; color: #A0AEC0; }
  100% { opacity: 0; color: #A0AEC0; pointer-events: none; }
}

@keyframes ecg-border-flow {
  to {
    stroke-dashoffset: -48;
  }
}

@keyframes standby-scan {
  0% { x: 5%; }
  50% { x: 70%; }
  100% { x: 5%; }
}
@keyframes idle-pulse {
  from { stroke-dashoffset: 1200; }
  to { stroke-dashoffset: 0; }
}

@keyframes boot-up-item {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes aurora {
  from {
    background-position: 0% 50%;
  }
  to {
    background-position: 200% 50%;
  }
}

@keyframes chart-draw-animation {
  to {
    stroke-dashoffset: 0;
  }
}

@keyframes chart-wipe-animation {
    to {
        clip-path: inset(0 0 0 0);
    }
}

@keyframes fade-in-slide-up {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes startup-fade-in-scale {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes startup-slide-in-left {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes startup-slide-in-right {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes startup-fade-in-from-center {
  from {
    opacity: 0;
    transform: scale(0.8);
    filter: blur(10px);
  }
  to {
    opacity: 1;
    transform: scale(1);
    filter: blur(0px);
  }
}

@keyframes global-indicator-fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes global-indicator-bars-grow {
  from { transform: scaleY(0); opacity: 0; }
  to { transform: scaleY(1); opacity: 1; }
}

@keyframes global-indicator-waveform-draw {
  from { stroke-dashoffset: 1000; }
  to { stroke-dashoffset: 0; }
}

@keyframes global-indicator-ecg-center-expand {
  0% {
    stroke-dasharray: 0 1000;
    stroke-dashoffset: 500;
    opacity: 0;
  }
  50% {
    stroke-dasharray: 500 500;
    stroke-dashoffset: 0;
    opacity: 1;
  }
  100% {
    stroke-dasharray: 1000 0;
    stroke-dashoffset: 0;
    opacity: 1;
  }
}

@keyframes app-shutdown {
  0% {
    filter: blur(0px) brightness(1) saturate(1);
    transform: scale(1);
    opacity: 1;
  }
  50% {
    filter: blur(2px) brightness(0.7) saturate(0.7);
    transform: scale(0.99);
    opacity: 0.8;
  }
  100% {
    filter: blur(5px) brightness(0.4) saturate(0.4);
    transform: scale(0.98);
    opacity: 0.5;
  }
}

@keyframes fluorescent-flicker {
  0% {
    opacity: 1;
    filter: brightness(1) grayscale(0);
    transform: scale(1);
  }
  10% {
    opacity: 0.1;
    filter: brightness(0.3) grayscale(1);
    transform: scale(0.98);
  }
  20% {
    opacity: 0.7;
    filter: brightness(1.1) grayscale(0);
    transform: scale(1.01);
  }
  30% {
    opacity: 0.2;
    filter: brightness(0.4) grayscale(1);
    transform: scale(0.97);
  }
  40% {
    opacity: 0.9;
    filter: brightness(1.05) grayscale(0);
    transform: scale(1);
  }
  50% {
    opacity: 0.15;
    filter: brightness(0.35) grayscale(1);
    transform: scale(0.96);
  }
  60% {
    opacity: 0.6;
    filter: brightness(0.9) grayscale(0);
    transform: scale(0.99);
  }
  70% {
    opacity: 0.05;
    filter: brightness(0.2) grayscale(1);
    transform: scale(0.95);
  }
  80% {
    opacity: 0.3;
    filter: brightness(0.5) grayscale(1);
    transform: scale(0.93);
  }
  90% {
    opacity: 0.02;
    filter: brightness(0.1) grayscale(1);
    transform: scale(0.92);
  }
  100% {
    opacity: 0;
    filter: brightness(0) grayscale(1);
    transform: scale(0.9);
    pointer-events: none;
  }
}

@keyframes staggered-fade-out {
  0% { opacity: 1; transform: translateY(0); pointer-events: auto; }
  100% { opacity: 0; transform: translateY(10px); pointer-events: none; }
}

@keyframes asic-border-draw-in {
  from {
    stroke-dasharray: 0 1000;
    stroke-dashoffset: 0;
    opacity: 0;
  }
  to {
    stroke-dasharray: 1000 0;
    stroke-dashoffset: 0;
    opacity: 1;
  }
}

@keyframes card-fill-from-top {
  from {
    clip-path: inset(100% 0 0 0);
  }
  to {
    clip-path: inset(0% 0 0 0);
  }
}

@keyframes hashrate-glitch-keyframes {
  0% {
    stroke-dasharray: 34 8;
    stroke-dashoffset: 8;
  }
  100% {
    stroke-dasharray: 34 8;
    stroke-dashoffset: -34;
  }
}

@keyframes button-build-animation {
  0% {
    clip-path: inset(50% 50% 50% 50%);
    opacity: 0;
  }
  5% {
    opacity: 1;
  }
  20% {
    clip-path: inset(calc(50% - 0.5px) 0% calc(50% - 0.5px) 0%);
  }
  40% {
    clip-path: inset(0% 0% 0% 0%);
  }
  100% {
    clip-path: inset(0% 0% 0% 0%);
    opacity: 1;
  }
}

@keyframes button-content-fade-in {
  0% { opacity: 0; }
  60% { opacity: 0; }
  100% { opacity: 1; }
}

@keyframes hexagon-orbital-path {
  0% { transform: rotate(0deg); }
  25% { transform: rotate(90deg); }
  50% { transform: rotate(90deg); }
  75% { transform: rotate(180deg); }
  100% { transform: rotate(180deg); }
}

@keyframes hexagon-local-spin-and-flash {
  0% { transform: rotate(0deg); filter: brightness(1) drop-shadow(0 0 0 white); }
  25% { transform: rotate(0deg); filter: brightness(1) drop-shadow(0 0 0 white); }
  50% { transform: rotate(360deg); filter: brightness(1) drop-shadow(0 0 0 white); }
  75% { transform: rotate(360deg); filter: brightness(1) drop-shadow(0 0 0 white); }
  85% { transform: rotate(360deg); filter: brightness(10) drop-shadow(0 0 20px white); }
  100% { transform: rotate(360deg); filter: brightness(1) drop-shadow(0 0 0 white); }
}

@keyframes button-morph-to-hex {
  0% { border-radius: 9999px; transform: rotate(0deg) scale(1); }
  50% { border-radius: 0; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); transform: rotate(180deg) scale(1.1); }
  100% { border-radius: 0; clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); transform: rotate(360deg) scale(0); opacity: 0; }
}

@keyframes red-hex-appear {
  0% { transform: scale(0) rotate(-45deg); opacity: 0; filter: drop-shadow(0 0 0 red); }
  50% { transform: scale(1.2) rotate(10deg); opacity: 1; filter: drop-shadow(0 0 20px red); }
  100% { transform: scale(1) rotate(0deg); opacity: 1; filter: drop-shadow(0 0 10px red); }
}

@keyframes red-line-draw {
  from { stroke-dashoffset: 400; }
  to { stroke-dashoffset: 0; }
}

@keyframes terminal-box-reveal {
  0% { transform: scaleX(0); opacity: 0; }
  100% { transform: scaleX(1); opacity: 1; }
}

@keyframes hex-flicker-red-orange {
  0%, 100% { color: #ef4444; filter: drop-shadow(0 0 10px #ef4444); }
  50% { color: #f97316; filter: drop-shadow(0 0 20px #f97316); }
}

@keyframes powerful-white-flash {
  0% { opacity: 0; }
  50% { opacity: 1; background-color: white; }
  100% { opacity: 0; }
}

/* NOUVELLES ANIMATIONS POUR LE VISEUR */
@keyframes target-bracket-in {
  0% { transform: translate(var(--tx), var(--ty)) scale(2); opacity: 0; }
  100% { transform: translate(0, 0) scale(1); opacity: 1; }
}

@keyframes target-lock-pulse {
  0%, 100% { transform: scale(1); filter: brightness(1); }
  50% { transform: scale(0.95); filter: brightness(1.5); }
}

@layer components {
  .animate-hashrate-glitch {
    animation: hashrate-glitch-keyframes 1.4s linear infinite;
  }

  .animate-zap-trace polygon {
    stroke-dasharray: 60;
    stroke-dashoffset: 60;
    animation: zap-trace 2.5s linear infinite;
    fill: none;
  }

  .animate-server-blink .light-1 {
    animation: server-blink 1.5s infinite;
    stroke-width: 3;
  }
  .animate-server-blink .light-2 {
    animation: server-blink 1.5s infinite 0.5s;
    stroke-width: 3;
  }
  .animate-server-blink .light-3 {
    animation: server-blink 1.5s infinite 0.2s;
    stroke-width: 3;
  }
  .animate-server-blink .light-4 {
    animation: server-blink 1.5s infinite 0.7s;
    stroke-width: 3;
  }
  .animate-server-blink .light-5 {
    animation: server-blink 1.5s infinite 0.4s;
    stroke-width: 3;
  }
  .animate-server-blink .light-6 {
    animation: server-blink 1.5s infinite 0.9s;
    stroke-width: 3;
  }
  .animate-server-blink .light-7 {
    animation: server-blink 1.5s infinite 0.1s;
    stroke-width: 3;
  }
  .animate-server-blink .light-8 {
    animation: server-blink 1.5s infinite 0.6s;
    stroke-width: 3;
  }
  
  .animate-marching-ants {
    stroke-dasharray: 12 24;
    animation: marching-ants 1s linear infinite;
  }

  .animate-slide-in-item {
    animation: slide-in-item 0.3s ease-out forwards;
    opacity: 0;
  }

  .animate-draw-border {
    animation: draw-border 0.5s ease-out forwards;
    animation-delay: inherit;
  }

  .animate-flicker-in {
    animation: flicker-in 0.8s ease-in-out forwards;
    animation-delay: inherit;
    opacity: 0;
  }

  .group:hover .animate-ecg-on-hover {
    stroke-dasharray: 8 4 2 4 2 4;
    animation: ecg-border-flow 0.75s linear infinite;
  }

  .animate-shutdown-wave {
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    animation: shutdown-wave 0.8s ease-out forwards;
  }

  .animate-flicker-and-fade {
    animation: flicker-and-fade 1.5s forwards;
    animation-delay: inherit;
  }

  .animate-gentle-shutdown {
    animation: gentle-shutdown-flicker 1.2s ease-out forwards;
    animation-delay: inherit;
  }

  .animate-standby-scan {
    animation: standby-scan 4s ease-in-out infinite;
  }
  .animate-idle-pulse {
    stroke-dasharray: 50 1150;
    animation: idle-pulse 8s linear infinite;
  }

  .animate-boot-up-item {
    animation: boot-up-item 0.5s ease-out forwards;
    opacity: 0;
  }

  .animate-aurora {
    animation: aurora 6s linear infinite;
  }

  .chart-line-draw .recharts-area-curve {
    stroke-dasharray: 2000;
    stroke-dashoffset: 2000;
    animation: chart-draw-animation 1.5s ease-out forwards;
  }

  .chart-area-draw .recharts-area-path {
      clip-path: inset(0 100% 0 0);
      animation: chart-wipe-animation 1.5s ease-out forwards;
  }

  .animate-fade-in-slide-up {
    animation: fade-in-slide-up 0.4s ease-out forwards;
    opacity: 0;
  }

  .animate-startup-fade-in-scale {
    animation: startup-fade-in-scale 0.6s ease-out forwards;
    opacity: 0;
  }

  .animate-startup-slide-in-left {
    animation: startup-slide-in-left 0.5s ease-out forwards;
    opacity: 0;
  }

  .animate-startup-slide-in-right {
    animation: startup-slide-in-right 0.5s ease-out forwards;
    opacity: 0;
  }

  .animate-startup-fade-in-from-center {
    animation: startup-fade-in-from-center 1s ease-out forwards;
    opacity: 0;
  }

  .animate-global-indicator-fade-in {
    animation: global-indicator-fade-in 0.5s ease-out forwards;
    opacity: 0;
  }

  .animate-global-indicator-bars-grow {
    animation: global-indicator-bars-grow 0.6s ease-out forwards;
    transform-origin: center bottom;
    opacity: 0;
  }

  .animate-global-indicator-waveform-draw {
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    animation: global-indicator-waveform-draw 1s ease-out forwards;
  }

  .animate-global-indicator-ecg-center-expand {
    stroke-dasharray: 0 1000;
    stroke-dashoffset: 500;
    animation: global-indicator-ecg-center-expand 1.2s ease-out forwards;
    opacity: 0;
  }

  .animate-app-shutdown {
    animation: app-shutdown 3s ease-out forwards;
  }

  .animate-staggered-fade-out {
    animation: staggered-fade-out 0.5s ease-out forwards;
    animation-delay: var(--delay, 0s);
  }

  .animate-asic-border-draw-in {
    animation: asic-border-draw-in 0.8s ease-out forwards;
    stroke-dasharray: 0 1000;
    stroke-dashoffset: 0;
    opacity: 0;
  }

  .animate-button-build {
    animation: button-build-animation 1s ease-out forwards;
    opacity: 0;
  }

  .animate-button-content-fade-in {
    animation: button-content-fade-in 0.5s ease-out forwards;
    opacity: 0;
  }

  .animate-hexagon-orbital {
    animation: hexagon-orbital-path 4s ease-in-out infinite;
    transform-origin: center center;
  }

  .animate-hexagon-spin-flash {
    animation: hexagon-local-spin-and-flash 4s ease-in-out infinite;
    transform-origin: center center;
  }

  .animate-button-morph-hex {
    animation: button-morph-to-hex 1s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .animate-red-hex-appear {
    animation: red-hex-appear 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
  }

  .animate-red-line-draw {
    stroke-dasharray: 400;
    stroke-dashoffset: 400;
    animation: red-line-draw 0.8s ease-out forwards;
  }

  .animate-box-reveal {
    animation: terminal-box-reveal 0.4s ease-out forwards;
    transform-origin: left;
  }

  .animate-hex-red-orange {
    animation: hex-flicker-red-orange 0.3s ease-in-out infinite;
  }

  .animate-final-flash {
    animation: powerful-white-flash 0.5s ease-out forwards;
  }

  .animate-target-lock {
    animation: target-lock-pulse 0.4s ease-in-out infinite;
  }
}

@layer utilities {
  .typewriter-cursor::after {
    content: '_';
    display: inline-block;
    vertical-align: text-bottom;
    animation: blink-caret 1s step-end infinite;
  }
}
</dyad-file>

<dyad-write path="src/components/NeuralHexNetwork.tsx" description="Refonte du réseau pour supporter l'Agent Rouge avec physique de répulsion, connexions en pointillés et bouclier hexagonal">
"use client";

import React, { useEffect, useRef } from 'react';

interface Particle {
  x: number;
  y: number;
  size: number;
  baseX: number;
  baseY: number;
  angle: number;
  speed: number;
  vx: number;
  vy: number;
  isRed?: boolean;
  phaseIn?: number; // 0 to 1 for progressive appearance
}

interface NeuralHexNetworkProps {
  redHexActive?: boolean;
  terminalBoxPos?: { x: number; y: number };
  onRedHexPos?: (pos: { x: number; y: number }) => void;
}

export const NeuralHexNetwork = ({ redHexActive, terminalBoxPos, onRedHexPos }: NeuralHexNetworkProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const mouseRef = useRef({ x: 0, y: 0, active: false });
  const redHexRef = useRef<Particle | null>(null);
  const shieldRef = useRef({ opacity: 0, timestamp: 0 });

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let animationFrameId: number;
    let particles: Particle[] = [];

    const resize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initParticles();
    };

    const initParticles = () => {
      particles = [];
      const numberOfParticles = Math.floor((canvas.width * canvas.height) / 4000);
      
      for (let i = 0; i < numberOfParticles; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        particles.push({
          x,
          y,
          baseX: x,
          baseY: y,
          size: Math.random() * 11 + 1,
          angle: Math.random() * Math.PI * 2,
          speed: Math.random() * 2 + 1,
          vx: (Math.random() - 0.5) * 2.5,
          vy: (Math.random() - 0.5) * 2.5
        });
      }

      // Initialize Red Hex
      redHexRef.current = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        baseX: canvas.width / 2,
        baseY: canvas.height / 2,
        size: 8,
        angle: 0,
        speed: 3,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        isRed: true,
        phaseIn: 0
      };
    };

    const drawHexagon = (ctx: CanvasRenderingContext2D, x: number, y: number, size: number, options: { fill?: string, stroke?: string, lineWidth?: number } = {}) => {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        ctx.lineTo(
          x + size * Math.cos((i * Math.PI) / 3),
          y + size * Math.sin((i * Math.PI) / 3)
        );
      }
      ctx.closePath();
      if (options.fill) {
        ctx.fillStyle = options.fill;
        ctx.fill();
      }
      if (options.stroke) {
        ctx.strokeStyle = options.stroke;
        ctx.lineWidth = options.lineWidth || 1;
        ctx.stroke();
      }
    };

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const connectionLimit = 80;
      const redHex = redHexRef.current;

      // Update Red Hex Phase and movement
      if (redHexActive && redHex) {
        if (redHex.phaseIn! < 1) redHex.phaseIn! += 0.01;
        
        redHex.baseX += redHex.vx;
        redHex.baseY += redHex.vy;
        
        // Bounce off walls
        if (redHex.baseX < 50 || redHex.baseX > canvas.width - 50) redHex.vx *= -1;
        if (redHex.baseY < 50 || redHex.baseY > canvas.height - 50) redHex.vy *= -1;

        // Collision with Terminal Box
        if (terminalBoxPos) {
          const dx = terminalBoxPos.x - redHex.baseX;
          const dy = terminalBoxPos.y - redHex.baseY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 180) { // Safety margin
            redHex.vx = -redHex.vx * 1.2;
            redHex.vy = -redHex.vy * 1.2;
            shieldRef.current = { opacity: 1, timestamp: Date.now() };
          }
        }

        redHex.x = redHex.baseX + Math.sin(Date.now() / 200) * 10;
        redHex.y = redHex.baseY + Math.cos(Date.now() / 200) * 10;
        
        if (onRedHexPos) onRedHexPos({ x: redHex.x, y: redHex.y });
      }

      // Draw Particles and Connections
      particles.forEach(p => {
        p.angle += 0.05;
        p.baseX += p.vx;
        p.baseY += p.vy;

        if (p.baseX < 0 || p.baseX > canvas.width) p.vx *= -1;
        if (p.baseY < 0 || p.baseY > canvas.height) p.vy *= -1;

        p.x = p.baseX + Math.cos(p.angle) * 10;
        p.y = p.baseY + Math.sin(p.angle) * 10;

        // Draw regular particle connections
        particles.forEach(p2 => {
          if (p === p2) return;
          const dx = p2.x - p.x;
          const dy = p2.y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < connectionLimit) {
            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = `rgba(34, 197, 94, 0.15)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        });

        // Connections with Red Hex
        if (redHexActive && redHex && redHex.phaseIn! > 0.5) {
          const dx = redHex.x - p.x;
          const dy = redHex.y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < connectionLimit + 20) {
            ctx.beginPath();
            ctx.setLineDash([2, 3]); // Dotted lines
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(redHex.x, redHex.y);
            ctx.strokeStyle = `rgba(239, 68, 68, ${0.4 * redHex.phaseIn!})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        // Draw green particle
        ctx.strokeStyle = `rgba(34, 197, 94, 0.6)`;
        ctx.setLineDash([]);
        drawHexagon(ctx, p.x, p.y, p.size, { stroke: `rgba(34, 197, 94, 0.6)` });
      });

      // Draw Red Hex if active
      if (redHexActive && redHex) {
        const glitch = Math.random() > 0.9 ? (Math.random() - 0.5) * 10 : 0;
        ctx.strokeStyle = `rgba(239, 68, 68, ${redHex.phaseIn})`;
        ctx.setLineDash([]);
        drawHexagon(ctx, redHex.x + glitch, redHex.y, redHex.size, { 
          stroke: `rgba(239, 68, 68, ${redHex.phaseIn})`,
          lineWidth: 2 
        });
      }

      // Draw Shield if active
      if (shieldRef.current.opacity > 0 && terminalBoxPos) {
        const elapsed = Date.now() - shieldRef.current.timestamp;
        shieldRef.current.opacity = Math.max(0, 1 - elapsed / 500);
        
        ctx.setLineDash([]);
        drawHexagon(ctx, terminalBoxPos.x, terminalBoxPos.y, 160, { 
          stroke: `rgba(239, 68, 68, ${shieldRef.current.opacity})`,
          lineWidth: 2
        });
        // Inner glowing effect
        drawHexagon(ctx, terminalBoxPos.x, terminalBoxPos.y, 160, { 
          fill: `rgba(239, 68, 68, ${shieldRef.current.opacity * 0.1})`
        });
      }

      animationFrameId = requestAnimationFrame(animate);
    };

    const handleMouseMove = (e: MouseEvent) => {
      mouseRef.current = { x: e.clientX, y: e.clientY, active: true };
    };

    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', handleMouseMove);
    
    resize();
    animate();

    return () => {
      window.removeEventListener('resize', resize);
      window.removeEventListener('mousemove', handleMouseMove);
      cancelAnimationFrame(animationFrameId);
    };
  }, [redHexActive, terminalBoxPos]);

  return <canvas ref={canvasRef} className="w-full h-full" />;
};